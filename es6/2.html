<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>胡乱练习下</title>
</head>
<body>
    <script>
        let a = {}
        a.fn1 = function () {
            //a.fn1 函数执行的时候它的上下文是 a
            //在这里声明的箭头函数的 this 也会是a
            console.log(this)
            return () => {
                console.log(this)
            }
        }

        //这里的函数调用就不是在 a 的对象上来调用函数了，而是在 window 对象上调用函数，因为a.fn()返回的函数返回到了 window 的上下文中。
        a.fn1()()

        sayThis = () => {
            //这里的 this 在函数声明的时候就一定决定好了
            console.log(this)
        }
        let DC = function () {
            this.name = "dc"
            this.age = 34
            console.log(this.hasOwnProperty())
            this.say = function() {
                console.log(this)
            },
            this.sayArrow = () => {
                console.log(this)
            }
            this.sayThis = sayThis
        }

        //如此看来 js 中的Arguments，Array 的这些数据类型都是使用构造函数来创建的
        dd = new DC()
        console.log(dd)
        dd.say()
        dd.sayArrow()
        dd.sayThis()

        //生成器
        //js 中的定时器就是异步
        function one() {
            setTimeout(()=>{
                console.log(1111)
                iterator.next(2)
            }, 1000)
        }
        function two(n) {
            setTimeout(()=>{
                console.log(n)
                iterator.next()
            }, 2000)
        }
        function three() {
            setTimeout(()=>{
                console.log(3333)
            }, 3000)
        }

        function * get() {
            let n = yield one()
            yield two(n)
            yield three()
        }

        let iterator = get()
        console.log(iterator)
        iterator.next()
         
        //set
        let arr = [1,2,3,4,5]
        let s = new Set(arr)
        console.log(s, typeof s)
        //数组求交集
        let arr1 = [4,5,6,7,9]
        let s1= new Set(arr1)
        let result = [...s].filter((item) => s1.has(item))
        console.log(result)
        //数组求并集
        let bingji = [...new Set([...s, ...s1])]
        console.log(bingji)

        //map
        //跟 object 不一样的是map 的 key 可以是任意的数据类型
        let m = new Map()
        m.set("name", "dx")
        console.log(m)


        //class
        function Parent() {
            
        }
        let p = new Parent()
        console.log(p)

        class Phone {
            //类的静态方法，不会被实例所继承，只能有类静态调用
            static lang = "en"
            constructor(size, price) {
                this.size = size
                this.price = price
            }
        
            call(msg) {
                console.log("我可以打电话...", msg)
            }
        }


        class SmartPhone extends Phone {
            constructor(size, price, os) {
                super(size, price)
                this.os = os
            }

            call() {
                //子类调用父类的方法
                super.call("form iphone")
                console.log("我可以打视频电话...")
            }

            game() {
                console.log("我可以拨打视频电话")
            }

            get os() {
                //Maximum call stack size  可以使用数据代理的方式来避免无限调用栈的问题
                return this._os
                console.log("os属性被读取了")
            }

            set os(v) {
                this._os = v
                console.log("os属性被设置了")
            }
        }
        console.log(Phone.lang)
        let nokia = new Phone(6, 1999)
        console.log(nokia)
        nokia.call()

        iphone = new SmartPhone(6, 4999, "ios")
        console.log(iphone)
        iphone.call()
        iphone.os = "andriod"
        console.log(iphone.os)


</script>
    
</body>
</html>